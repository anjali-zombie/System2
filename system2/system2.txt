When a linker runs, it first has to scan the input files to find the sizes of the
segments and to collect the definitions and references of all of the symbols
It creates a segment table listing all of the segments defined in the input
files, and a symbol table with all of the symbols imported or exported.
Using the data from the first pass, the linker assigns numeric locations to
symbols, determines the sizes and location of the segments in the output
address space, and figures out where everything goes in the output file.
The second pass uses the information collected in the first pass to control
the actual linking process.

------------------------------------------------------------------------------------------------------------------------------system2 notes:-
Topics to read:
->assembly to object code conversion
->object code to assembly conversion
->what is system program
->diffrence between listing file and object code file generated by translating assembly program using nasm
->binutils(nm utility) algorithm to implement this utility
->why symbol table used and explaination of data structure why specific data structure used to implement symbol table
-> errors assembler should detect
->symbol table
->literal table
-> error table
->opcode table
-> static memmory allocation performed during which stage
->what is language processor
-> relocatable and non- relocatable program
->memory allocation of assembly program
-> pass
->MOD R/M byte
->SIB byte
-> jump instruction in forward and backward refrence
->lex and yacc
------------------------------------------------------------------------------------------------------------------------------
to create 32 bit file write command:- gcc -m32 first.c
to know the contents file"hexdump a.out"  is used,it shows whole code in ascii 

objedump -D a.out|less: shows information from object file

nm a.out: list all symbols of file
 ELF:executable and linkable file eg:a.out

man nm:- D for intialized identifier 
B for unintialized identifier
U undefined
-> -g Fdwarf add debugging symbol to the compiled file
-> start of program from:-_start->_libc_start_main(){it found main() in execution and start executing}-> main()->{then contol return back to}libc_start_main()
->readelf -s first.0 => display symbol table
->readelf -h first.o => shows elf header:
-magic
-class
-data
-version
-os/abi
-abi version
-type
-machine
-version
-entry point addresss
-start of program headers
-start of section headers
-flags
-size of this header
-size of program header
-number of program headers
-size of section headers
-number of section headers
-section header string table index
  


Book:-------------------------------------------------------------------------------------------------------------------------
An assembler is a translator that translates source instructions (in symbolic language) into target instructions (in machine language), on a one to one basis.
Compilers being translators of problem-oriented languages or of machine-independent languages.
he assembler language depends heavily on the internal organization of the computer
It was this task of locating, loading,and linking—of assembling a single working program from individual pieces—that created the name assembler.

TYPES of assembler:

A One-pass Assembler: One that performs all its functions by reading the source file once.
A Two-Pass Assembler: One that reads the source file twice.
A Resident Assembler: One that is permanently loaded in memory. Typicallysuch an assembler resides in ROM, is very simple (supports only a few directives and no macros), and is a one-pass assembler.
A Macro-Assembler: One that supports macros (chapter 4).
A Cross-Assembler: An assembler that runs on one computer and assembles pro-
grams for another. Many cross-assemblers are written in a higher-level language to
make them portable. They run on a large machine and produce object code for a
small machine.
A Meta-Assembler: One that can handle many different instruction sets.
A Disassembler: This, in a sense, is the opposite of an assembler. It translates
machine code into a source program in assembler language.

The comment is for the programmer’s use only. It is read by the assembler, it
is listed in the listing file, and is otherwise ignored.

It
turns out to be a simple problem and there are two solutions, a one-pass assembler
and a two-pass assembler. They represent not just different solutions to the future
symbol problem but two different approaches to assembler design and operation.
The one-pass assembler, as the name implies, solves the future symbol problem
by reading the source file once. Its most important feature, however, is that it
does not generate a relocatable object file but rather loads the object code (the
machine language program)directly into memory. Similarly, the most important
feature of the two-pass assembler is that it generates a relocatable object file, that
is later loaded into memory by a loader. 

two pass assembler:-
in first pass all labels are collected and inserted in symbol table and instructions remain unassembled which is assembled in second pass
 
